package com.dongfeng.study.basicstudy.java.otherbasic;

/**
 * <b> Java重写（override）与重载（overload）学习 </b>
 *
 * @author eastFeng
 * @date 2021-04-23 0:31
 */
public class OverrideAndOverloadStudy {
    public static void main(String[] args) {

    }

    private String des;

    /**
     * <p> ● 构造器与类同名
     * <p> ● 每个类可以有一个以上的构造器
     * <p> ● 构造器可以有0个、1个或多个参数
     * <p> ● 构造器没有返回值
     * <p> ● 构造器总是伴随着new操作一起调用
     */
    public OverrideAndOverloadStudy(){}

    public OverrideAndOverloadStudy(String des){
        this.des = des;
    }

    /**
     * 重写父类Object中的toString方法
     */
    @Override
    public String toString(){
        return des;
    }

    /**
     * 重写
     */
    public static void override(){
        /*
         * 重写是【子类对父类】的【允许访问的方法】的实现过程进行重新编写, 方法名和参数列表都必须相同。【即外壳不变，核心重写！】
         * 返回值范围小于等于父类，抛出的异常范围小于等于父类。
         *
         * 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。
         *
         * 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
         * 例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，
         * 因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。
         *
         * 子类可以重写父类非private的方法（父类的private方法子类不允许访问）
         * private变量和方法只能在类内访问，访问的也永远是当前类的，即：在子类中访问的是子类的；在父类中访问的是父类的，
         * 它们只是碰巧名字一样而已，没有任何关系。
         *
         * 方法的重写规则：
         * 1. 参数列表与被重写方法的参数列表必须完全相同。
         * 2. 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的子类（java5及更早版本返回类型要一样，java7及更高版本可以不同）。
         * 3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
         * 4. 父类的成员方法只能被它的子类重写。
         * 5. 声明为 final 的方法不能被重写。
         * 6. 声明为 static 的方法不能被重写，但是能够被再次声明。
         * 7. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
         * 8. 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
         * 9. 构造方法不能被重写。
         * 10. 如果不能继承一个类，则不能重写该类的方法。
         *
         * 当需要在子类中调用父类的被重写方法时，要使用 super 关键字。（不用super会调用本类的方法）
         */

    }

    /**
     * 重载
     */
    public static void overload(){
        /*
         *
         * 重载是【在一个类里面】，【方法名称相同但参数签名不同】（参数个数、类型或顺序不同）。返回类型可以相同也可以不同。
         *
         * 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
         *
         * 如果多个方法（比如多个构造器方法）有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，
         * 它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。
         * 如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。
         * （这个过程被称为重载解析（overloading resolution）。）
         * Java允许重载任何方法，而不只是构造器方法。
         *
         * 因此，要完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。
         * 返回类型不是方法签名的一部分。也就是说，不能有两个名字相同、参数类型也相同却返回不同类型值的方法。
         *
         * 重载规则：
         * 1. 被重载的方法必须改变参数列表(参数个数或类型不一样)
         * 2. 被重载的方法可以改变返回类型
         * 3. 被重载的方法可以改变访问修饰符
         * 4. 被重载的方法可以声明新的或更广的检查异常
         * 5. 方法能够在同一个类中或者在一个子类中被重载
         * 6. 不能以返回值类型作为重载函数的区分标准
         */

    }
}
