package com.dongfeng.study.basicstudy;

/**
 * <b> Java接口（interface）学习 </b>
 *
 * @author eastFeng
 * @date 2021-04-21 17:00
 */
public interface InterfaceStudy {
    /*
     * 接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。
     * 接口不是类，尤其不能使用new运算符实例化一个接口。
     *
     * 尽管不能构造接口的对象，却能声明接口的变量：Comparable x;           // ok
     * 接口变量必须引用实现了接口的类对象：x = new ArrayList<String>();  // ok
     * 也可以使用instanceof检查一个对象是否实现了某个特定的接口：if(anObject instanceof Comparable){...}
     *
     * 与可以建立类的继承关系一样，接口也可以被扩展。但与类不同的是，接口可以有多个父接口。
     *
     *
     * 尽管每个类只能够拥有一个超类，但却可以实现多个接口。这就为定义类的行为提供了极大的灵活性。使用逗号将实现的各个接口分隔开。
     * 实现接口必须要实现接口中声明的抽象方法。
     * 【接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定】。
     * 类可以实现接口，表示类的对象具有接口所表示的能力。
     *
     * 个人理解：类是描述这个东西是啥，接口是描述具有的一种属性、功能、能力。
     * 比如一个类Door（门），还有一个接口PasswordLock（密码锁）。一个类WoodenDoor（木门）继承了Door，我们知道了
     * WoodenDoor表示一个门，WoodenDoor实现了PasswordLock接口，它就有了密码锁这个属性、功能、能力。
     *
     * 针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式
     * 优点：
     * 1. 代码复用。
     *    同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力（实现了相同的接口），如Comparable。
     * 2. 接口更重要的是降低了耦合，提高了灵活性。
     *    使用接口的代码依赖的是接口本身，而非实现接口的具体类型，程序可以根据情况替换接口的实现，而不影响接口使用者。
     */

    /**
     * 接口中的所有方法自动地属于public。因此，在接口中声明方法时，不必提供关键字public。
     * <p> 在Java 8之前，接口中的方法都是抽象方法，都没有实现体，
     * <p> Java 8允许在接口中定义两类新方法：静态方法和默认方法，它们有实现体
     * <p> 没有方法体的接口方法不需要加修饰符，加与不加相当于都是public abstract
     * <p> 不过，一个类在实现接口时，实现抽象方法时必须把方法声明为public。
     */
    void des();

    String getUrl();

    /**
     * <b> 静态方法 </b>
     *
     * <p> 该静态方法可以直接通过InterfaceStudy.test()调用
     * <p>比如，Comparator接口就定义了多个静态方法。
     */
    static void test(){
        System.out.println("hello");
    }
    static String getStr(){
        return "hello";
    }

    /**
     * <b> 默认方法 </b>
     *
     * <p> 默认方法 ：可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。
     * <p> 默认方法只能在接口只用声明：default 关键字只能在接口中使用。
     * <p> 每个实现类都可以重写默认方法。实现类可以改变它的实现，也可以不改变。
     * <p> 引入默认方法主要是函数式数据处理的需求，是为了便于给接口增加功能
     *
     * <p> 如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生什么情况？解决默认方法冲突：
     * <p> 1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。
     * <p> 2）接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，
     *       必须覆盖这个方法来解决冲突。
     * @param name 姓名
     * @return hello
     */
    default String hello(String name){
        return "Hello " + name;
    }

    /**
     * 在接口中还可以定义常量。
     * <p> 接口绝不能含有实例域。
     * <p> 虽然在接口中不能包含实例域或静态方法，但却可以包含常量。
     * <p> 与接口中的方法都自动地被设置为public一样，接口中的域将被自动设为public static final
     */
    String URL = "http://www.baidu.com";

}
